// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `sentencepiece_model.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:sentencepiece.TrainerSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainerSpec {
    // message fields
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.input)
    pub input: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.input_format)
    pub input_format: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.model_prefix)
    pub model_prefix: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.model_type)
    pub model_type: ::std::option::Option<::protobuf::EnumOrUnknown<trainer_spec::ModelType>>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.vocab_size)
    pub vocab_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.accept_language)
    pub accept_language: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.self_test_sample_size)
    pub self_test_sample_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.enable_differential_privacy)
    pub enable_differential_privacy: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.differential_privacy_noise_level)
    pub differential_privacy_noise_level: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.differential_privacy_clipping_threshold)
    pub differential_privacy_clipping_threshold: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.character_coverage)
    pub character_coverage: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.input_sentence_size)
    pub input_sentence_size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.shuffle_input_sentence)
    pub shuffle_input_sentence: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.mining_sentence_size)
    pub mining_sentence_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.training_sentence_size)
    pub training_sentence_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.seed_sentencepiece_size)
    pub seed_sentencepiece_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.shrinking_factor)
    pub shrinking_factor: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.max_sentence_length)
    pub max_sentence_length: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.num_threads)
    pub num_threads: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.num_sub_iterations)
    pub num_sub_iterations: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.max_sentencepiece_length)
    pub max_sentencepiece_length: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.split_by_unicode_script)
    pub split_by_unicode_script: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.split_by_number)
    pub split_by_number: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.split_by_whitespace)
    pub split_by_whitespace: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.treat_whitespace_as_suffix)
    pub treat_whitespace_as_suffix: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.allow_whitespace_only_pieces)
    pub allow_whitespace_only_pieces: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.split_digits)
    pub split_digits: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.control_symbols)
    pub control_symbols: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.user_defined_symbols)
    pub user_defined_symbols: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.required_chars)
    pub required_chars: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.byte_fallback)
    pub byte_fallback: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.vocabulary_output_piece_score)
    pub vocabulary_output_piece_score: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.hard_vocab_limit)
    pub hard_vocab_limit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.use_all_vocab)
    pub use_all_vocab: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.unk_id)
    pub unk_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.bos_id)
    pub bos_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.eos_id)
    pub eos_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.pad_id)
    pub pad_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.unk_piece)
    pub unk_piece: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.bos_piece)
    pub bos_piece: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.eos_piece)
    pub eos_piece: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.pad_piece)
    pub pad_piece: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.unk_surface)
    pub unk_surface: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:sentencepiece.TrainerSpec.train_extremely_large_corpus)
    pub train_extremely_large_corpus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:sentencepiece.TrainerSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainerSpec {
    fn default() -> &'a TrainerSpec {
        <TrainerSpec as ::protobuf::Message>::default_instance()
    }
}

impl TrainerSpec {
    pub fn new() -> TrainerSpec {
        ::std::default::Default::default()
    }

    // optional string input_format = 7;

    pub fn input_format(&self) -> &str {
        match self.input_format.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_input_format(&mut self) {
        self.input_format = ::std::option::Option::None;
    }

    pub fn has_input_format(&self) -> bool {
        self.input_format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_format(&mut self, v: ::std::string::String) {
        self.input_format = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_format(&mut self) -> &mut ::std::string::String {
        if self.input_format.is_none() {
            self.input_format = ::std::option::Option::Some(::std::string::String::new());
        }
        self.input_format.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_format(&mut self) -> ::std::string::String {
        self.input_format.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string model_prefix = 2;

    pub fn model_prefix(&self) -> &str {
        match self.model_prefix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_model_prefix(&mut self) {
        self.model_prefix = ::std::option::Option::None;
    }

    pub fn has_model_prefix(&self) -> bool {
        self.model_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_prefix(&mut self, v: ::std::string::String) {
        self.model_prefix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_prefix(&mut self) -> &mut ::std::string::String {
        if self.model_prefix.is_none() {
            self.model_prefix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.model_prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_model_prefix(&mut self) -> ::std::string::String {
        self.model_prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .sentencepiece.TrainerSpec.ModelType model_type = 3;

    pub fn model_type(&self) -> trainer_spec::ModelType {
        match self.model_type {
            Some(e) => e.enum_value_or(trainer_spec::ModelType::UNIGRAM),
            None => trainer_spec::ModelType::UNIGRAM,
        }
    }

    pub fn clear_model_type(&mut self) {
        self.model_type = ::std::option::Option::None;
    }

    pub fn has_model_type(&self) -> bool {
        self.model_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_type(&mut self, v: trainer_spec::ModelType) {
        self.model_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 vocab_size = 4;

    pub fn vocab_size(&self) -> i32 {
        self.vocab_size.unwrap_or(8000i32)
    }

    pub fn clear_vocab_size(&mut self) {
        self.vocab_size = ::std::option::Option::None;
    }

    pub fn has_vocab_size(&self) -> bool {
        self.vocab_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vocab_size(&mut self, v: i32) {
        self.vocab_size = ::std::option::Option::Some(v);
    }

    // optional int32 self_test_sample_size = 6;

    pub fn self_test_sample_size(&self) -> i32 {
        self.self_test_sample_size.unwrap_or(0i32)
    }

    pub fn clear_self_test_sample_size(&mut self) {
        self.self_test_sample_size = ::std::option::Option::None;
    }

    pub fn has_self_test_sample_size(&self) -> bool {
        self.self_test_sample_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_self_test_sample_size(&mut self, v: i32) {
        self.self_test_sample_size = ::std::option::Option::Some(v);
    }

    // optional bool enable_differential_privacy = 50;

    pub fn enable_differential_privacy(&self) -> bool {
        self.enable_differential_privacy.unwrap_or(false)
    }

    pub fn clear_enable_differential_privacy(&mut self) {
        self.enable_differential_privacy = ::std::option::Option::None;
    }

    pub fn has_enable_differential_privacy(&self) -> bool {
        self.enable_differential_privacy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_differential_privacy(&mut self, v: bool) {
        self.enable_differential_privacy = ::std::option::Option::Some(v);
    }

    // optional float differential_privacy_noise_level = 51;

    pub fn differential_privacy_noise_level(&self) -> f32 {
        self.differential_privacy_noise_level.unwrap_or(0.0f32)
    }

    pub fn clear_differential_privacy_noise_level(&mut self) {
        self.differential_privacy_noise_level = ::std::option::Option::None;
    }

    pub fn has_differential_privacy_noise_level(&self) -> bool {
        self.differential_privacy_noise_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_differential_privacy_noise_level(&mut self, v: f32) {
        self.differential_privacy_noise_level = ::std::option::Option::Some(v);
    }

    // optional uint64 differential_privacy_clipping_threshold = 52;

    pub fn differential_privacy_clipping_threshold(&self) -> u64 {
        self.differential_privacy_clipping_threshold.unwrap_or(0u64)
    }

    pub fn clear_differential_privacy_clipping_threshold(&mut self) {
        self.differential_privacy_clipping_threshold = ::std::option::Option::None;
    }

    pub fn has_differential_privacy_clipping_threshold(&self) -> bool {
        self.differential_privacy_clipping_threshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_differential_privacy_clipping_threshold(&mut self, v: u64) {
        self.differential_privacy_clipping_threshold = ::std::option::Option::Some(v);
    }

    // optional float character_coverage = 10;

    pub fn character_coverage(&self) -> f32 {
        self.character_coverage.unwrap_or(0.9994999766349792f32)
    }

    pub fn clear_character_coverage(&mut self) {
        self.character_coverage = ::std::option::Option::None;
    }

    pub fn has_character_coverage(&self) -> bool {
        self.character_coverage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_character_coverage(&mut self, v: f32) {
        self.character_coverage = ::std::option::Option::Some(v);
    }

    // optional uint64 input_sentence_size = 11;

    pub fn input_sentence_size(&self) -> u64 {
        self.input_sentence_size.unwrap_or(0u64)
    }

    pub fn clear_input_sentence_size(&mut self) {
        self.input_sentence_size = ::std::option::Option::None;
    }

    pub fn has_input_sentence_size(&self) -> bool {
        self.input_sentence_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_sentence_size(&mut self, v: u64) {
        self.input_sentence_size = ::std::option::Option::Some(v);
    }

    // optional bool shuffle_input_sentence = 19;

    pub fn shuffle_input_sentence(&self) -> bool {
        self.shuffle_input_sentence.unwrap_or(true)
    }

    pub fn clear_shuffle_input_sentence(&mut self) {
        self.shuffle_input_sentence = ::std::option::Option::None;
    }

    pub fn has_shuffle_input_sentence(&self) -> bool {
        self.shuffle_input_sentence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shuffle_input_sentence(&mut self, v: bool) {
        self.shuffle_input_sentence = ::std::option::Option::Some(v);
    }

    // optional int32 mining_sentence_size = 12;

    pub fn mining_sentence_size(&self) -> i32 {
        self.mining_sentence_size.unwrap_or(0)
    }

    pub fn clear_mining_sentence_size(&mut self) {
        self.mining_sentence_size = ::std::option::Option::None;
    }

    pub fn has_mining_sentence_size(&self) -> bool {
        self.mining_sentence_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mining_sentence_size(&mut self, v: i32) {
        self.mining_sentence_size = ::std::option::Option::Some(v);
    }

    // optional int32 training_sentence_size = 13;

    pub fn training_sentence_size(&self) -> i32 {
        self.training_sentence_size.unwrap_or(0)
    }

    pub fn clear_training_sentence_size(&mut self) {
        self.training_sentence_size = ::std::option::Option::None;
    }

    pub fn has_training_sentence_size(&self) -> bool {
        self.training_sentence_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_training_sentence_size(&mut self, v: i32) {
        self.training_sentence_size = ::std::option::Option::Some(v);
    }

    // optional int32 seed_sentencepiece_size = 14;

    pub fn seed_sentencepiece_size(&self) -> i32 {
        self.seed_sentencepiece_size.unwrap_or(1000000i32)
    }

    pub fn clear_seed_sentencepiece_size(&mut self) {
        self.seed_sentencepiece_size = ::std::option::Option::None;
    }

    pub fn has_seed_sentencepiece_size(&self) -> bool {
        self.seed_sentencepiece_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seed_sentencepiece_size(&mut self, v: i32) {
        self.seed_sentencepiece_size = ::std::option::Option::Some(v);
    }

    // optional float shrinking_factor = 15;

    pub fn shrinking_factor(&self) -> f32 {
        self.shrinking_factor.unwrap_or(0.75f32)
    }

    pub fn clear_shrinking_factor(&mut self) {
        self.shrinking_factor = ::std::option::Option::None;
    }

    pub fn has_shrinking_factor(&self) -> bool {
        self.shrinking_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shrinking_factor(&mut self, v: f32) {
        self.shrinking_factor = ::std::option::Option::Some(v);
    }

    // optional int32 max_sentence_length = 18;

    pub fn max_sentence_length(&self) -> i32 {
        self.max_sentence_length.unwrap_or(4192i32)
    }

    pub fn clear_max_sentence_length(&mut self) {
        self.max_sentence_length = ::std::option::Option::None;
    }

    pub fn has_max_sentence_length(&self) -> bool {
        self.max_sentence_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_sentence_length(&mut self, v: i32) {
        self.max_sentence_length = ::std::option::Option::Some(v);
    }

    // optional int32 num_threads = 16;

    pub fn num_threads(&self) -> i32 {
        self.num_threads.unwrap_or(16i32)
    }

    pub fn clear_num_threads(&mut self) {
        self.num_threads = ::std::option::Option::None;
    }

    pub fn has_num_threads(&self) -> bool {
        self.num_threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_threads(&mut self, v: i32) {
        self.num_threads = ::std::option::Option::Some(v);
    }

    // optional int32 num_sub_iterations = 17;

    pub fn num_sub_iterations(&self) -> i32 {
        self.num_sub_iterations.unwrap_or(2i32)
    }

    pub fn clear_num_sub_iterations(&mut self) {
        self.num_sub_iterations = ::std::option::Option::None;
    }

    pub fn has_num_sub_iterations(&self) -> bool {
        self.num_sub_iterations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_sub_iterations(&mut self, v: i32) {
        self.num_sub_iterations = ::std::option::Option::Some(v);
    }

    // optional int32 max_sentencepiece_length = 20;

    pub fn max_sentencepiece_length(&self) -> i32 {
        self.max_sentencepiece_length.unwrap_or(16i32)
    }

    pub fn clear_max_sentencepiece_length(&mut self) {
        self.max_sentencepiece_length = ::std::option::Option::None;
    }

    pub fn has_max_sentencepiece_length(&self) -> bool {
        self.max_sentencepiece_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_sentencepiece_length(&mut self, v: i32) {
        self.max_sentencepiece_length = ::std::option::Option::Some(v);
    }

    // optional bool split_by_unicode_script = 21;

    pub fn split_by_unicode_script(&self) -> bool {
        self.split_by_unicode_script.unwrap_or(true)
    }

    pub fn clear_split_by_unicode_script(&mut self) {
        self.split_by_unicode_script = ::std::option::Option::None;
    }

    pub fn has_split_by_unicode_script(&self) -> bool {
        self.split_by_unicode_script.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_by_unicode_script(&mut self, v: bool) {
        self.split_by_unicode_script = ::std::option::Option::Some(v);
    }

    // optional bool split_by_number = 23;

    pub fn split_by_number(&self) -> bool {
        self.split_by_number.unwrap_or(true)
    }

    pub fn clear_split_by_number(&mut self) {
        self.split_by_number = ::std::option::Option::None;
    }

    pub fn has_split_by_number(&self) -> bool {
        self.split_by_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_by_number(&mut self, v: bool) {
        self.split_by_number = ::std::option::Option::Some(v);
    }

    // optional bool split_by_whitespace = 22;

    pub fn split_by_whitespace(&self) -> bool {
        self.split_by_whitespace.unwrap_or(true)
    }

    pub fn clear_split_by_whitespace(&mut self) {
        self.split_by_whitespace = ::std::option::Option::None;
    }

    pub fn has_split_by_whitespace(&self) -> bool {
        self.split_by_whitespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_by_whitespace(&mut self, v: bool) {
        self.split_by_whitespace = ::std::option::Option::Some(v);
    }

    // optional bool treat_whitespace_as_suffix = 24;

    pub fn treat_whitespace_as_suffix(&self) -> bool {
        self.treat_whitespace_as_suffix.unwrap_or(false)
    }

    pub fn clear_treat_whitespace_as_suffix(&mut self) {
        self.treat_whitespace_as_suffix = ::std::option::Option::None;
    }

    pub fn has_treat_whitespace_as_suffix(&self) -> bool {
        self.treat_whitespace_as_suffix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_treat_whitespace_as_suffix(&mut self, v: bool) {
        self.treat_whitespace_as_suffix = ::std::option::Option::Some(v);
    }

    // optional bool allow_whitespace_only_pieces = 26;

    pub fn allow_whitespace_only_pieces(&self) -> bool {
        self.allow_whitespace_only_pieces.unwrap_or(false)
    }

    pub fn clear_allow_whitespace_only_pieces(&mut self) {
        self.allow_whitespace_only_pieces = ::std::option::Option::None;
    }

    pub fn has_allow_whitespace_only_pieces(&self) -> bool {
        self.allow_whitespace_only_pieces.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_whitespace_only_pieces(&mut self, v: bool) {
        self.allow_whitespace_only_pieces = ::std::option::Option::Some(v);
    }

    // optional bool split_digits = 25;

    pub fn split_digits(&self) -> bool {
        self.split_digits.unwrap_or(false)
    }

    pub fn clear_split_digits(&mut self) {
        self.split_digits = ::std::option::Option::None;
    }

    pub fn has_split_digits(&self) -> bool {
        self.split_digits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_digits(&mut self, v: bool) {
        self.split_digits = ::std::option::Option::Some(v);
    }

    // optional string required_chars = 36;

    pub fn required_chars(&self) -> &str {
        match self.required_chars.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_required_chars(&mut self) {
        self.required_chars = ::std::option::Option::None;
    }

    pub fn has_required_chars(&self) -> bool {
        self.required_chars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_chars(&mut self, v: ::std::string::String) {
        self.required_chars = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_required_chars(&mut self) -> &mut ::std::string::String {
        if self.required_chars.is_none() {
            self.required_chars = ::std::option::Option::Some(::std::string::String::new());
        }
        self.required_chars.as_mut().unwrap()
    }

    // Take field
    pub fn take_required_chars(&mut self) -> ::std::string::String {
        self.required_chars.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool byte_fallback = 35;

    pub fn byte_fallback(&self) -> bool {
        self.byte_fallback.unwrap_or(false)
    }

    pub fn clear_byte_fallback(&mut self) {
        self.byte_fallback = ::std::option::Option::None;
    }

    pub fn has_byte_fallback(&self) -> bool {
        self.byte_fallback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_byte_fallback(&mut self, v: bool) {
        self.byte_fallback = ::std::option::Option::Some(v);
    }

    // optional bool vocabulary_output_piece_score = 32;

    pub fn vocabulary_output_piece_score(&self) -> bool {
        self.vocabulary_output_piece_score.unwrap_or(true)
    }

    pub fn clear_vocabulary_output_piece_score(&mut self) {
        self.vocabulary_output_piece_score = ::std::option::Option::None;
    }

    pub fn has_vocabulary_output_piece_score(&self) -> bool {
        self.vocabulary_output_piece_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vocabulary_output_piece_score(&mut self, v: bool) {
        self.vocabulary_output_piece_score = ::std::option::Option::Some(v);
    }

    // optional bool hard_vocab_limit = 33;

    pub fn hard_vocab_limit(&self) -> bool {
        self.hard_vocab_limit.unwrap_or(true)
    }

    pub fn clear_hard_vocab_limit(&mut self) {
        self.hard_vocab_limit = ::std::option::Option::None;
    }

    pub fn has_hard_vocab_limit(&self) -> bool {
        self.hard_vocab_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hard_vocab_limit(&mut self, v: bool) {
        self.hard_vocab_limit = ::std::option::Option::Some(v);
    }

    // optional bool use_all_vocab = 34;

    pub fn use_all_vocab(&self) -> bool {
        self.use_all_vocab.unwrap_or(false)
    }

    pub fn clear_use_all_vocab(&mut self) {
        self.use_all_vocab = ::std::option::Option::None;
    }

    pub fn has_use_all_vocab(&self) -> bool {
        self.use_all_vocab.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_all_vocab(&mut self, v: bool) {
        self.use_all_vocab = ::std::option::Option::Some(v);
    }

    // optional int32 unk_id = 40;

    pub fn unk_id(&self) -> i32 {
        self.unk_id.unwrap_or(0i32)
    }

    pub fn clear_unk_id(&mut self) {
        self.unk_id = ::std::option::Option::None;
    }

    pub fn has_unk_id(&self) -> bool {
        self.unk_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unk_id(&mut self, v: i32) {
        self.unk_id = ::std::option::Option::Some(v);
    }

    // optional int32 bos_id = 41;

    pub fn bos_id(&self) -> i32 {
        self.bos_id.unwrap_or(1i32)
    }

    pub fn clear_bos_id(&mut self) {
        self.bos_id = ::std::option::Option::None;
    }

    pub fn has_bos_id(&self) -> bool {
        self.bos_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bos_id(&mut self, v: i32) {
        self.bos_id = ::std::option::Option::Some(v);
    }

    // optional int32 eos_id = 42;

    pub fn eos_id(&self) -> i32 {
        self.eos_id.unwrap_or(2i32)
    }

    pub fn clear_eos_id(&mut self) {
        self.eos_id = ::std::option::Option::None;
    }

    pub fn has_eos_id(&self) -> bool {
        self.eos_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eos_id(&mut self, v: i32) {
        self.eos_id = ::std::option::Option::Some(v);
    }

    // optional int32 pad_id = 43;

    pub fn pad_id(&self) -> i32 {
        self.pad_id.unwrap_or(-1i32)
    }

    pub fn clear_pad_id(&mut self) {
        self.pad_id = ::std::option::Option::None;
    }

    pub fn has_pad_id(&self) -> bool {
        self.pad_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pad_id(&mut self, v: i32) {
        self.pad_id = ::std::option::Option::Some(v);
    }

    // optional string unk_piece = 45;

    pub fn unk_piece(&self) -> &str {
        match self.unk_piece.as_ref() {
            Some(v) => v,
            None => "<unk>",
        }
    }

    pub fn clear_unk_piece(&mut self) {
        self.unk_piece = ::std::option::Option::None;
    }

    pub fn has_unk_piece(&self) -> bool {
        self.unk_piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unk_piece(&mut self, v: ::std::string::String) {
        self.unk_piece = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unk_piece(&mut self) -> &mut ::std::string::String {
        if self.unk_piece.is_none() {
            self.unk_piece = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unk_piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_unk_piece(&mut self) -> ::std::string::String {
        self.unk_piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bos_piece = 46;

    pub fn bos_piece(&self) -> &str {
        match self.bos_piece.as_ref() {
            Some(v) => v,
            None => "<s>",
        }
    }

    pub fn clear_bos_piece(&mut self) {
        self.bos_piece = ::std::option::Option::None;
    }

    pub fn has_bos_piece(&self) -> bool {
        self.bos_piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bos_piece(&mut self, v: ::std::string::String) {
        self.bos_piece = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bos_piece(&mut self) -> &mut ::std::string::String {
        if self.bos_piece.is_none() {
            self.bos_piece = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bos_piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_bos_piece(&mut self) -> ::std::string::String {
        self.bos_piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string eos_piece = 47;

    pub fn eos_piece(&self) -> &str {
        match self.eos_piece.as_ref() {
            Some(v) => v,
            None => "</s>",
        }
    }

    pub fn clear_eos_piece(&mut self) {
        self.eos_piece = ::std::option::Option::None;
    }

    pub fn has_eos_piece(&self) -> bool {
        self.eos_piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eos_piece(&mut self, v: ::std::string::String) {
        self.eos_piece = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eos_piece(&mut self) -> &mut ::std::string::String {
        if self.eos_piece.is_none() {
            self.eos_piece = ::std::option::Option::Some(::std::string::String::new());
        }
        self.eos_piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_eos_piece(&mut self) -> ::std::string::String {
        self.eos_piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pad_piece = 48;

    pub fn pad_piece(&self) -> &str {
        match self.pad_piece.as_ref() {
            Some(v) => v,
            None => "<pad>",
        }
    }

    pub fn clear_pad_piece(&mut self) {
        self.pad_piece = ::std::option::Option::None;
    }

    pub fn has_pad_piece(&self) -> bool {
        self.pad_piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pad_piece(&mut self, v: ::std::string::String) {
        self.pad_piece = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pad_piece(&mut self) -> &mut ::std::string::String {
        if self.pad_piece.is_none() {
            self.pad_piece = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pad_piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_pad_piece(&mut self) -> ::std::string::String {
        self.pad_piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string unk_surface = 44;

    pub fn unk_surface(&self) -> &str {
        match self.unk_surface.as_ref() {
            Some(v) => v,
            None => " \u{2047} ",
        }
    }

    pub fn clear_unk_surface(&mut self) {
        self.unk_surface = ::std::option::Option::None;
    }

    pub fn has_unk_surface(&self) -> bool {
        self.unk_surface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unk_surface(&mut self, v: ::std::string::String) {
        self.unk_surface = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unk_surface(&mut self) -> &mut ::std::string::String {
        if self.unk_surface.is_none() {
            self.unk_surface = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unk_surface.as_mut().unwrap()
    }

    // Take field
    pub fn take_unk_surface(&mut self) -> ::std::string::String {
        self.unk_surface.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool train_extremely_large_corpus = 49;

    pub fn train_extremely_large_corpus(&self) -> bool {
        self.train_extremely_large_corpus.unwrap_or(false)
    }

    pub fn clear_train_extremely_large_corpus(&mut self) {
        self.train_extremely_large_corpus = ::std::option::Option::None;
    }

    pub fn has_train_extremely_large_corpus(&self) -> bool {
        self.train_extremely_large_corpus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_train_extremely_large_corpus(&mut self, v: bool) {
        self.train_extremely_large_corpus = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TrainerSpec {
    const NAME: &'static str = "TrainerSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.input.push(is.read_string()?);
                },
                58 => {
                    self.input_format = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.model_prefix = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.model_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.vocab_size = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.accept_language.push(is.read_string()?);
                },
                48 => {
                    self.self_test_sample_size = ::std::option::Option::Some(is.read_int32()?);
                },
                400 => {
                    self.enable_differential_privacy = ::std::option::Option::Some(is.read_bool()?);
                },
                413 => {
                    self.differential_privacy_noise_level = ::std::option::Option::Some(is.read_float()?);
                },
                416 => {
                    self.differential_privacy_clipping_threshold = ::std::option::Option::Some(is.read_uint64()?);
                },
                85 => {
                    self.character_coverage = ::std::option::Option::Some(is.read_float()?);
                },
                88 => {
                    self.input_sentence_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                152 => {
                    self.shuffle_input_sentence = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.mining_sentence_size = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.training_sentence_size = ::std::option::Option::Some(is.read_int32()?);
                },
                112 => {
                    self.seed_sentencepiece_size = ::std::option::Option::Some(is.read_int32()?);
                },
                125 => {
                    self.shrinking_factor = ::std::option::Option::Some(is.read_float()?);
                },
                144 => {
                    self.max_sentence_length = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.num_threads = ::std::option::Option::Some(is.read_int32()?);
                },
                136 => {
                    self.num_sub_iterations = ::std::option::Option::Some(is.read_int32()?);
                },
                160 => {
                    self.max_sentencepiece_length = ::std::option::Option::Some(is.read_int32()?);
                },
                168 => {
                    self.split_by_unicode_script = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.split_by_number = ::std::option::Option::Some(is.read_bool()?);
                },
                176 => {
                    self.split_by_whitespace = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.treat_whitespace_as_suffix = ::std::option::Option::Some(is.read_bool()?);
                },
                208 => {
                    self.allow_whitespace_only_pieces = ::std::option::Option::Some(is.read_bool()?);
                },
                200 => {
                    self.split_digits = ::std::option::Option::Some(is.read_bool()?);
                },
                242 => {
                    self.control_symbols.push(is.read_string()?);
                },
                250 => {
                    self.user_defined_symbols.push(is.read_string()?);
                },
                290 => {
                    self.required_chars = ::std::option::Option::Some(is.read_string()?);
                },
                280 => {
                    self.byte_fallback = ::std::option::Option::Some(is.read_bool()?);
                },
                256 => {
                    self.vocabulary_output_piece_score = ::std::option::Option::Some(is.read_bool()?);
                },
                264 => {
                    self.hard_vocab_limit = ::std::option::Option::Some(is.read_bool()?);
                },
                272 => {
                    self.use_all_vocab = ::std::option::Option::Some(is.read_bool()?);
                },
                320 => {
                    self.unk_id = ::std::option::Option::Some(is.read_int32()?);
                },
                328 => {
                    self.bos_id = ::std::option::Option::Some(is.read_int32()?);
                },
                336 => {
                    self.eos_id = ::std::option::Option::Some(is.read_int32()?);
                },
                344 => {
                    self.pad_id = ::std::option::Option::Some(is.read_int32()?);
                },
                362 => {
                    self.unk_piece = ::std::option::Option::Some(is.read_string()?);
                },
                370 => {
                    self.bos_piece = ::std::option::Option::Some(is.read_string()?);
                },
                378 => {
                    self.eos_piece = ::std::option::Option::Some(is.read_string()?);
                },
                386 => {
                    self.pad_piece = ::std::option::Option::Some(is.read_string()?);
                },
                354 => {
                    self.unk_surface = ::std::option::Option::Some(is.read_string()?);
                },
                392 => {
                    self.train_extremely_large_corpus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.input {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.input_format.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.model_prefix.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.model_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.vocab_size {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        for value in &self.accept_language {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.self_test_sample_size {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.enable_differential_privacy {
            my_size += 2 + 1;
        }
        if let Some(v) = self.differential_privacy_noise_level {
            my_size += 2 + 4;
        }
        if let Some(v) = self.differential_privacy_clipping_threshold {
            my_size += ::protobuf::rt::uint64_size(52, v);
        }
        if let Some(v) = self.character_coverage {
            my_size += 1 + 4;
        }
        if let Some(v) = self.input_sentence_size {
            my_size += ::protobuf::rt::uint64_size(11, v);
        }
        if let Some(v) = self.shuffle_input_sentence {
            my_size += 2 + 1;
        }
        if let Some(v) = self.mining_sentence_size {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.training_sentence_size {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.seed_sentencepiece_size {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.shrinking_factor {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_sentence_length {
            my_size += ::protobuf::rt::int32_size(18, v);
        }
        if let Some(v) = self.num_threads {
            my_size += ::protobuf::rt::int32_size(16, v);
        }
        if let Some(v) = self.num_sub_iterations {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        if let Some(v) = self.max_sentencepiece_length {
            my_size += ::protobuf::rt::int32_size(20, v);
        }
        if let Some(v) = self.split_by_unicode_script {
            my_size += 2 + 1;
        }
        if let Some(v) = self.split_by_number {
            my_size += 2 + 1;
        }
        if let Some(v) = self.split_by_whitespace {
            my_size += 2 + 1;
        }
        if let Some(v) = self.treat_whitespace_as_suffix {
            my_size += 2 + 1;
        }
        if let Some(v) = self.allow_whitespace_only_pieces {
            my_size += 2 + 1;
        }
        if let Some(v) = self.split_digits {
            my_size += 2 + 1;
        }
        for value in &self.control_symbols {
            my_size += ::protobuf::rt::string_size(30, &value);
        };
        for value in &self.user_defined_symbols {
            my_size += ::protobuf::rt::string_size(31, &value);
        };
        if let Some(v) = self.required_chars.as_ref() {
            my_size += ::protobuf::rt::string_size(36, &v);
        }
        if let Some(v) = self.byte_fallback {
            my_size += 2 + 1;
        }
        if let Some(v) = self.vocabulary_output_piece_score {
            my_size += 2 + 1;
        }
        if let Some(v) = self.hard_vocab_limit {
            my_size += 2 + 1;
        }
        if let Some(v) = self.use_all_vocab {
            my_size += 2 + 1;
        }
        if let Some(v) = self.unk_id {
            my_size += ::protobuf::rt::int32_size(40, v);
        }
        if let Some(v) = self.bos_id {
            my_size += ::protobuf::rt::int32_size(41, v);
        }
        if let Some(v) = self.eos_id {
            my_size += ::protobuf::rt::int32_size(42, v);
        }
        if let Some(v) = self.pad_id {
            my_size += ::protobuf::rt::int32_size(43, v);
        }
        if let Some(v) = self.unk_piece.as_ref() {
            my_size += ::protobuf::rt::string_size(45, &v);
        }
        if let Some(v) = self.bos_piece.as_ref() {
            my_size += ::protobuf::rt::string_size(46, &v);
        }
        if let Some(v) = self.eos_piece.as_ref() {
            my_size += ::protobuf::rt::string_size(47, &v);
        }
        if let Some(v) = self.pad_piece.as_ref() {
            my_size += ::protobuf::rt::string_size(48, &v);
        }
        if let Some(v) = self.unk_surface.as_ref() {
            my_size += ::protobuf::rt::string_size(44, &v);
        }
        if let Some(v) = self.train_extremely_large_corpus {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.input {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.input_format.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.model_prefix.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.model_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.vocab_size {
            os.write_int32(4, v)?;
        }
        for v in &self.accept_language {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.self_test_sample_size {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.enable_differential_privacy {
            os.write_bool(50, v)?;
        }
        if let Some(v) = self.differential_privacy_noise_level {
            os.write_float(51, v)?;
        }
        if let Some(v) = self.differential_privacy_clipping_threshold {
            os.write_uint64(52, v)?;
        }
        if let Some(v) = self.character_coverage {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.input_sentence_size {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.shuffle_input_sentence {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.mining_sentence_size {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.training_sentence_size {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.seed_sentencepiece_size {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.shrinking_factor {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.max_sentence_length {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.num_threads {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.num_sub_iterations {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.max_sentencepiece_length {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.split_by_unicode_script {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.split_by_number {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.split_by_whitespace {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.treat_whitespace_as_suffix {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.allow_whitespace_only_pieces {
            os.write_bool(26, v)?;
        }
        if let Some(v) = self.split_digits {
            os.write_bool(25, v)?;
        }
        for v in &self.control_symbols {
            os.write_string(30, &v)?;
        };
        for v in &self.user_defined_symbols {
            os.write_string(31, &v)?;
        };
        if let Some(v) = self.required_chars.as_ref() {
            os.write_string(36, v)?;
        }
        if let Some(v) = self.byte_fallback {
            os.write_bool(35, v)?;
        }
        if let Some(v) = self.vocabulary_output_piece_score {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.hard_vocab_limit {
            os.write_bool(33, v)?;
        }
        if let Some(v) = self.use_all_vocab {
            os.write_bool(34, v)?;
        }
        if let Some(v) = self.unk_id {
            os.write_int32(40, v)?;
        }
        if let Some(v) = self.bos_id {
            os.write_int32(41, v)?;
        }
        if let Some(v) = self.eos_id {
            os.write_int32(42, v)?;
        }
        if let Some(v) = self.pad_id {
            os.write_int32(43, v)?;
        }
        if let Some(v) = self.unk_piece.as_ref() {
            os.write_string(45, v)?;
        }
        if let Some(v) = self.bos_piece.as_ref() {
            os.write_string(46, v)?;
        }
        if let Some(v) = self.eos_piece.as_ref() {
            os.write_string(47, v)?;
        }
        if let Some(v) = self.pad_piece.as_ref() {
            os.write_string(48, v)?;
        }
        if let Some(v) = self.unk_surface.as_ref() {
            os.write_string(44, v)?;
        }
        if let Some(v) = self.train_extremely_large_corpus {
            os.write_bool(49, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainerSpec {
        TrainerSpec::new()
    }

    fn clear(&mut self) {
        self.input.clear();
        self.input_format = ::std::option::Option::None;
        self.model_prefix = ::std::option::Option::None;
        self.model_type = ::std::option::Option::None;
        self.vocab_size = ::std::option::Option::None;
        self.accept_language.clear();
        self.self_test_sample_size = ::std::option::Option::None;
        self.enable_differential_privacy = ::std::option::Option::None;
        self.differential_privacy_noise_level = ::std::option::Option::None;
        self.differential_privacy_clipping_threshold = ::std::option::Option::None;
        self.character_coverage = ::std::option::Option::None;
        self.input_sentence_size = ::std::option::Option::None;
        self.shuffle_input_sentence = ::std::option::Option::None;
        self.mining_sentence_size = ::std::option::Option::None;
        self.training_sentence_size = ::std::option::Option::None;
        self.seed_sentencepiece_size = ::std::option::Option::None;
        self.shrinking_factor = ::std::option::Option::None;
        self.max_sentence_length = ::std::option::Option::None;
        self.num_threads = ::std::option::Option::None;
        self.num_sub_iterations = ::std::option::Option::None;
        self.max_sentencepiece_length = ::std::option::Option::None;
        self.split_by_unicode_script = ::std::option::Option::None;
        self.split_by_number = ::std::option::Option::None;
        self.split_by_whitespace = ::std::option::Option::None;
        self.treat_whitespace_as_suffix = ::std::option::Option::None;
        self.allow_whitespace_only_pieces = ::std::option::Option::None;
        self.split_digits = ::std::option::Option::None;
        self.control_symbols.clear();
        self.user_defined_symbols.clear();
        self.required_chars = ::std::option::Option::None;
        self.byte_fallback = ::std::option::Option::None;
        self.vocabulary_output_piece_score = ::std::option::Option::None;
        self.hard_vocab_limit = ::std::option::Option::None;
        self.use_all_vocab = ::std::option::Option::None;
        self.unk_id = ::std::option::Option::None;
        self.bos_id = ::std::option::Option::None;
        self.eos_id = ::std::option::Option::None;
        self.pad_id = ::std::option::Option::None;
        self.unk_piece = ::std::option::Option::None;
        self.bos_piece = ::std::option::Option::None;
        self.eos_piece = ::std::option::Option::None;
        self.pad_piece = ::std::option::Option::None;
        self.unk_surface = ::std::option::Option::None;
        self.train_extremely_large_corpus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainerSpec {
        static instance: TrainerSpec = TrainerSpec {
            input: ::std::vec::Vec::new(),
            input_format: ::std::option::Option::None,
            model_prefix: ::std::option::Option::None,
            model_type: ::std::option::Option::None,
            vocab_size: ::std::option::Option::None,
            accept_language: ::std::vec::Vec::new(),
            self_test_sample_size: ::std::option::Option::None,
            enable_differential_privacy: ::std::option::Option::None,
            differential_privacy_noise_level: ::std::option::Option::None,
            differential_privacy_clipping_threshold: ::std::option::Option::None,
            character_coverage: ::std::option::Option::None,
            input_sentence_size: ::std::option::Option::None,
            shuffle_input_sentence: ::std::option::Option::None,
            mining_sentence_size: ::std::option::Option::None,
            training_sentence_size: ::std::option::Option::None,
            seed_sentencepiece_size: ::std::option::Option::None,
            shrinking_factor: ::std::option::Option::None,
            max_sentence_length: ::std::option::Option::None,
            num_threads: ::std::option::Option::None,
            num_sub_iterations: ::std::option::Option::None,
            max_sentencepiece_length: ::std::option::Option::None,
            split_by_unicode_script: ::std::option::Option::None,
            split_by_number: ::std::option::Option::None,
            split_by_whitespace: ::std::option::Option::None,
            treat_whitespace_as_suffix: ::std::option::Option::None,
            allow_whitespace_only_pieces: ::std::option::Option::None,
            split_digits: ::std::option::Option::None,
            control_symbols: ::std::vec::Vec::new(),
            user_defined_symbols: ::std::vec::Vec::new(),
            required_chars: ::std::option::Option::None,
            byte_fallback: ::std::option::Option::None,
            vocabulary_output_piece_score: ::std::option::Option::None,
            hard_vocab_limit: ::std::option::Option::None,
            use_all_vocab: ::std::option::Option::None,
            unk_id: ::std::option::Option::None,
            bos_id: ::std::option::Option::None,
            eos_id: ::std::option::Option::None,
            pad_id: ::std::option::Option::None,
            unk_piece: ::std::option::Option::None,
            bos_piece: ::std::option::Option::None,
            eos_piece: ::std::option::Option::None,
            pad_piece: ::std::option::Option::None,
            unk_surface: ::std::option::Option::None,
            train_extremely_large_corpus: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `TrainerSpec`
pub mod trainer_spec {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:sentencepiece.TrainerSpec.ModelType)
    pub enum ModelType {
        // @@protoc_insertion_point(enum_value:sentencepiece.TrainerSpec.ModelType.UNIGRAM)
        UNIGRAM = 1,
        // @@protoc_insertion_point(enum_value:sentencepiece.TrainerSpec.ModelType.BPE)
        BPE = 2,
        // @@protoc_insertion_point(enum_value:sentencepiece.TrainerSpec.ModelType.WORD)
        WORD = 3,
        // @@protoc_insertion_point(enum_value:sentencepiece.TrainerSpec.ModelType.CHAR)
        CHAR = 4,
    }

    impl ::protobuf::Enum for ModelType {
        const NAME: &'static str = "ModelType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ModelType> {
            match value {
                1 => ::std::option::Option::Some(ModelType::UNIGRAM),
                2 => ::std::option::Option::Some(ModelType::BPE),
                3 => ::std::option::Option::Some(ModelType::WORD),
                4 => ::std::option::Option::Some(ModelType::CHAR),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ModelType> {
            match str {
                "UNIGRAM" => ::std::option::Option::Some(ModelType::UNIGRAM),
                "BPE" => ::std::option::Option::Some(ModelType::BPE),
                "WORD" => ::std::option::Option::Some(ModelType::WORD),
                "CHAR" => ::std::option::Option::Some(ModelType::CHAR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ModelType] = &[
            ModelType::UNIGRAM,
            ModelType::BPE,
            ModelType::WORD,
            ModelType::CHAR,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for ModelType {
        fn default() -> Self {
            ModelType::UNIGRAM
        }
    }

}

// @@protoc_insertion_point(message:sentencepiece.NormalizerSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NormalizerSpec {
    // message fields
    // @@protoc_insertion_point(field:sentencepiece.NormalizerSpec.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:sentencepiece.NormalizerSpec.precompiled_charsmap)
    pub precompiled_charsmap: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:sentencepiece.NormalizerSpec.add_dummy_prefix)
    pub add_dummy_prefix: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:sentencepiece.NormalizerSpec.remove_extra_whitespaces)
    pub remove_extra_whitespaces: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:sentencepiece.NormalizerSpec.escape_whitespaces)
    pub escape_whitespaces: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:sentencepiece.NormalizerSpec.normalization_rule_tsv)
    pub normalization_rule_tsv: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:sentencepiece.NormalizerSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NormalizerSpec {
    fn default() -> &'a NormalizerSpec {
        <NormalizerSpec as ::protobuf::Message>::default_instance()
    }
}

impl NormalizerSpec {
    pub fn new() -> NormalizerSpec {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes precompiled_charsmap = 2;

    pub fn precompiled_charsmap(&self) -> &[u8] {
        match self.precompiled_charsmap.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_precompiled_charsmap(&mut self) {
        self.precompiled_charsmap = ::std::option::Option::None;
    }

    pub fn has_precompiled_charsmap(&self) -> bool {
        self.precompiled_charsmap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_precompiled_charsmap(&mut self, v: ::std::vec::Vec<u8>) {
        self.precompiled_charsmap = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_precompiled_charsmap(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.precompiled_charsmap.is_none() {
            self.precompiled_charsmap = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.precompiled_charsmap.as_mut().unwrap()
    }

    // Take field
    pub fn take_precompiled_charsmap(&mut self) -> ::std::vec::Vec<u8> {
        self.precompiled_charsmap.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool add_dummy_prefix = 3;

    pub fn add_dummy_prefix(&self) -> bool {
        self.add_dummy_prefix.unwrap_or(true)
    }

    pub fn clear_add_dummy_prefix(&mut self) {
        self.add_dummy_prefix = ::std::option::Option::None;
    }

    pub fn has_add_dummy_prefix(&self) -> bool {
        self.add_dummy_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_dummy_prefix(&mut self, v: bool) {
        self.add_dummy_prefix = ::std::option::Option::Some(v);
    }

    // optional bool remove_extra_whitespaces = 4;

    pub fn remove_extra_whitespaces(&self) -> bool {
        self.remove_extra_whitespaces.unwrap_or(true)
    }

    pub fn clear_remove_extra_whitespaces(&mut self) {
        self.remove_extra_whitespaces = ::std::option::Option::None;
    }

    pub fn has_remove_extra_whitespaces(&self) -> bool {
        self.remove_extra_whitespaces.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_extra_whitespaces(&mut self, v: bool) {
        self.remove_extra_whitespaces = ::std::option::Option::Some(v);
    }

    // optional bool escape_whitespaces = 5;

    pub fn escape_whitespaces(&self) -> bool {
        self.escape_whitespaces.unwrap_or(true)
    }

    pub fn clear_escape_whitespaces(&mut self) {
        self.escape_whitespaces = ::std::option::Option::None;
    }

    pub fn has_escape_whitespaces(&self) -> bool {
        self.escape_whitespaces.is_some()
    }

    // Param is passed by value, moved
    pub fn set_escape_whitespaces(&mut self, v: bool) {
        self.escape_whitespaces = ::std::option::Option::Some(v);
    }

    // optional string normalization_rule_tsv = 6;

    pub fn normalization_rule_tsv(&self) -> &str {
        match self.normalization_rule_tsv.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_normalization_rule_tsv(&mut self) {
        self.normalization_rule_tsv = ::std::option::Option::None;
    }

    pub fn has_normalization_rule_tsv(&self) -> bool {
        self.normalization_rule_tsv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normalization_rule_tsv(&mut self, v: ::std::string::String) {
        self.normalization_rule_tsv = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_normalization_rule_tsv(&mut self) -> &mut ::std::string::String {
        if self.normalization_rule_tsv.is_none() {
            self.normalization_rule_tsv = ::std::option::Option::Some(::std::string::String::new());
        }
        self.normalization_rule_tsv.as_mut().unwrap()
    }

    // Take field
    pub fn take_normalization_rule_tsv(&mut self) -> ::std::string::String {
        self.normalization_rule_tsv.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for NormalizerSpec {
    const NAME: &'static str = "NormalizerSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.precompiled_charsmap = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.add_dummy_prefix = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.remove_extra_whitespaces = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.escape_whitespaces = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.normalization_rule_tsv = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.precompiled_charsmap.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.add_dummy_prefix {
            my_size += 1 + 1;
        }
        if let Some(v) = self.remove_extra_whitespaces {
            my_size += 1 + 1;
        }
        if let Some(v) = self.escape_whitespaces {
            my_size += 1 + 1;
        }
        if let Some(v) = self.normalization_rule_tsv.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.precompiled_charsmap.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.add_dummy_prefix {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.remove_extra_whitespaces {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.escape_whitespaces {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.normalization_rule_tsv.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NormalizerSpec {
        NormalizerSpec::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.precompiled_charsmap = ::std::option::Option::None;
        self.add_dummy_prefix = ::std::option::Option::None;
        self.remove_extra_whitespaces = ::std::option::Option::None;
        self.escape_whitespaces = ::std::option::Option::None;
        self.normalization_rule_tsv = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NormalizerSpec {
        static instance: NormalizerSpec = NormalizerSpec {
            name: ::std::option::Option::None,
            precompiled_charsmap: ::std::option::Option::None,
            add_dummy_prefix: ::std::option::Option::None,
            remove_extra_whitespaces: ::std::option::Option::None,
            escape_whitespaces: ::std::option::Option::None,
            normalization_rule_tsv: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:sentencepiece.SelfTestData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SelfTestData {
    // message fields
    // @@protoc_insertion_point(field:sentencepiece.SelfTestData.samples)
    pub samples: ::std::vec::Vec<self_test_data::Sample>,
    // special fields
    // @@protoc_insertion_point(special_field:sentencepiece.SelfTestData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelfTestData {
    fn default() -> &'a SelfTestData {
        <SelfTestData as ::protobuf::Message>::default_instance()
    }
}

impl SelfTestData {
    pub fn new() -> SelfTestData {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SelfTestData {
    const NAME: &'static str = "SelfTestData";

    fn is_initialized(&self) -> bool {
        for v in &self.samples {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.samples.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.samples {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.samples {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelfTestData {
        SelfTestData::new()
    }

    fn clear(&mut self) {
        self.samples.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelfTestData {
        static instance: SelfTestData = SelfTestData {
            samples: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `SelfTestData`
pub mod self_test_data {
    // @@protoc_insertion_point(message:sentencepiece.SelfTestData.Sample)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Sample {
        // message fields
        // @@protoc_insertion_point(field:sentencepiece.SelfTestData.Sample.input)
        pub input: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:sentencepiece.SelfTestData.Sample.expected)
        pub expected: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:sentencepiece.SelfTestData.Sample.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sample {
        fn default() -> &'a Sample {
            <Sample as ::protobuf::Message>::default_instance()
        }
    }

    impl Sample {
        pub fn new() -> Sample {
            ::std::default::Default::default()
        }

        // optional string input = 1;

        pub fn input(&self) -> &str {
            match self.input.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_input(&mut self) {
            self.input = ::std::option::Option::None;
        }

        pub fn has_input(&self) -> bool {
            self.input.is_some()
        }

        // Param is passed by value, moved
        pub fn set_input(&mut self, v: ::std::string::String) {
            self.input = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_input(&mut self) -> &mut ::std::string::String {
            if self.input.is_none() {
                self.input = ::std::option::Option::Some(::std::string::String::new());
            }
            self.input.as_mut().unwrap()
        }

        // Take field
        pub fn take_input(&mut self) -> ::std::string::String {
            self.input.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string expected = 2;

        pub fn expected(&self) -> &str {
            match self.expected.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_expected(&mut self) {
            self.expected = ::std::option::Option::None;
        }

        pub fn has_expected(&self) -> bool {
            self.expected.is_some()
        }

        // Param is passed by value, moved
        pub fn set_expected(&mut self, v: ::std::string::String) {
            self.expected = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_expected(&mut self) -> &mut ::std::string::String {
            if self.expected.is_none() {
                self.expected = ::std::option::Option::Some(::std::string::String::new());
            }
            self.expected.as_mut().unwrap()
        }

        // Take field
        pub fn take_expected(&mut self) -> ::std::string::String {
            self.expected.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for Sample {
        const NAME: &'static str = "Sample";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.input = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.expected = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.input.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.expected.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.input.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.expected.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sample {
            Sample::new()
        }

        fn clear(&mut self) {
            self.input = ::std::option::Option::None;
            self.expected = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sample {
            static instance: Sample = Sample {
                input: ::std::option::Option::None,
                expected: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:sentencepiece.ModelProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelProto {
    // message fields
    // @@protoc_insertion_point(field:sentencepiece.ModelProto.pieces)
    pub pieces: ::std::vec::Vec<model_proto::SentencePiece>,
    // @@protoc_insertion_point(field:sentencepiece.ModelProto.trainer_spec)
    pub trainer_spec: ::protobuf::MessageField<TrainerSpec>,
    // @@protoc_insertion_point(field:sentencepiece.ModelProto.normalizer_spec)
    pub normalizer_spec: ::protobuf::MessageField<NormalizerSpec>,
    // @@protoc_insertion_point(field:sentencepiece.ModelProto.self_test_data)
    pub self_test_data: ::protobuf::MessageField<SelfTestData>,
    // @@protoc_insertion_point(field:sentencepiece.ModelProto.denormalizer_spec)
    pub denormalizer_spec: ::protobuf::MessageField<NormalizerSpec>,
    // special fields
    // @@protoc_insertion_point(special_field:sentencepiece.ModelProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelProto {
    fn default() -> &'a ModelProto {
        <ModelProto as ::protobuf::Message>::default_instance()
    }
}

impl ModelProto {
    pub fn new() -> ModelProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ModelProto {
    const NAME: &'static str = "ModelProto";

    fn is_initialized(&self) -> bool {
        for v in &self.pieces {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trainer_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.normalizer_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.self_test_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.denormalizer_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pieces.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trainer_spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.normalizer_spec)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.self_test_data)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.denormalizer_spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pieces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.trainer_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.normalizer_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.self_test_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.denormalizer_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pieces {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.trainer_spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.normalizer_spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.self_test_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.denormalizer_spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelProto {
        ModelProto::new()
    }

    fn clear(&mut self) {
        self.pieces.clear();
        self.trainer_spec.clear();
        self.normalizer_spec.clear();
        self.self_test_data.clear();
        self.denormalizer_spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelProto {
        static instance: ModelProto = ModelProto {
            pieces: ::std::vec::Vec::new(),
            trainer_spec: ::protobuf::MessageField::none(),
            normalizer_spec: ::protobuf::MessageField::none(),
            self_test_data: ::protobuf::MessageField::none(),
            denormalizer_spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `ModelProto`
pub mod model_proto {
    // @@protoc_insertion_point(message:sentencepiece.ModelProto.SentencePiece)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SentencePiece {
        // message fields
        // @@protoc_insertion_point(field:sentencepiece.ModelProto.SentencePiece.piece)
        pub piece: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:sentencepiece.ModelProto.SentencePiece.score)
        pub score: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:sentencepiece.ModelProto.SentencePiece.type)
        pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<sentence_piece::Type>>,
        // special fields
        // @@protoc_insertion_point(special_field:sentencepiece.ModelProto.SentencePiece.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SentencePiece {
        fn default() -> &'a SentencePiece {
            <SentencePiece as ::protobuf::Message>::default_instance()
        }
    }

    impl SentencePiece {
        pub fn new() -> SentencePiece {
            ::std::default::Default::default()
        }

        // optional string piece = 1;

        pub fn piece(&self) -> &str {
            match self.piece.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_piece(&mut self) {
            self.piece = ::std::option::Option::None;
        }

        pub fn has_piece(&self) -> bool {
            self.piece.is_some()
        }

        // Param is passed by value, moved
        pub fn set_piece(&mut self, v: ::std::string::String) {
            self.piece = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_piece(&mut self) -> &mut ::std::string::String {
            if self.piece.is_none() {
                self.piece = ::std::option::Option::Some(::std::string::String::new());
            }
            self.piece.as_mut().unwrap()
        }

        // Take field
        pub fn take_piece(&mut self) -> ::std::string::String {
            self.piece.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional float score = 2;

        pub fn score(&self) -> f32 {
            self.score.unwrap_or(0.)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: f32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional .sentencepiece.ModelProto.SentencePiece.Type type = 3;

        pub fn type_(&self) -> sentence_piece::Type {
            match self.type_ {
                Some(e) => e.enum_value_or(sentence_piece::Type::NORMAL),
                None => sentence_piece::Type::NORMAL,
            }
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: sentence_piece::Type) {
            self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::protobuf::Message for SentencePiece {
        const NAME: &'static str = "SentencePiece";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.piece = ::std::option::Option::Some(is.read_string()?);
                    },
                    21 => {
                        self.score = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.piece.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.score {
                my_size += 1 + 4;
            }
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.piece.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.score {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.type_ {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SentencePiece {
            SentencePiece::new()
        }

        fn clear(&mut self) {
            self.piece = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SentencePiece {
            static instance: SentencePiece = SentencePiece {
                piece: ::std::option::Option::None,
                score: ::std::option::Option::None,
                type_: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `SentencePiece`
    pub mod sentence_piece {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:sentencepiece.ModelProto.SentencePiece.Type)
        pub enum Type {
            // @@protoc_insertion_point(enum_value:sentencepiece.ModelProto.SentencePiece.Type.NORMAL)
            NORMAL = 1,
            // @@protoc_insertion_point(enum_value:sentencepiece.ModelProto.SentencePiece.Type.UNKNOWN)
            UNKNOWN = 2,
            // @@protoc_insertion_point(enum_value:sentencepiece.ModelProto.SentencePiece.Type.CONTROL)
            CONTROL = 3,
            // @@protoc_insertion_point(enum_value:sentencepiece.ModelProto.SentencePiece.Type.USER_DEFINED)
            USER_DEFINED = 4,
            // @@protoc_insertion_point(enum_value:sentencepiece.ModelProto.SentencePiece.Type.BYTE)
            BYTE = 6,
            // @@protoc_insertion_point(enum_value:sentencepiece.ModelProto.SentencePiece.Type.UNUSED)
            UNUSED = 5,
        }

        impl ::protobuf::Enum for Type {
            const NAME: &'static str = "Type";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Type> {
                match value {
                    1 => ::std::option::Option::Some(Type::NORMAL),
                    2 => ::std::option::Option::Some(Type::UNKNOWN),
                    3 => ::std::option::Option::Some(Type::CONTROL),
                    4 => ::std::option::Option::Some(Type::USER_DEFINED),
                    6 => ::std::option::Option::Some(Type::BYTE),
                    5 => ::std::option::Option::Some(Type::UNUSED),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Type> {
                match str {
                    "NORMAL" => ::std::option::Option::Some(Type::NORMAL),
                    "UNKNOWN" => ::std::option::Option::Some(Type::UNKNOWN),
                    "CONTROL" => ::std::option::Option::Some(Type::CONTROL),
                    "USER_DEFINED" => ::std::option::Option::Some(Type::USER_DEFINED),
                    "BYTE" => ::std::option::Option::Some(Type::BYTE),
                    "UNUSED" => ::std::option::Option::Some(Type::UNUSED),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Type] = &[
                Type::NORMAL,
                Type::UNKNOWN,
                Type::CONTROL,
                Type::USER_DEFINED,
                Type::BYTE,
                Type::UNUSED,
            ];
        }

        // Note, `Default` is implemented although default value is not 0
        impl ::std::default::Default for Type {
            fn default() -> Self {
                Type::NORMAL
            }
        }

    }
}
